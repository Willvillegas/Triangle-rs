//! The Checker module.
//! This module traverses the AST generated by the Parser, checks that the AST is well-formed,
//! and decorates it with links from applied occurrences of identfiers to their corresponding declarations,
//! as well as expressions, type-denoters, and vnames with their type.

use crate::ast::aggregates::*;
use crate::ast::commands::*;
use crate::ast::declarations::*;
use crate::ast::expressions::*;
use crate::ast::parameters::*;
use crate::ast::primitives::*;
use crate::ast::typedenoters::*;
use crate::ast::vnames::*;
use crate::ast::*;
use crate::error::{report_error_and_exit, CheckerError, GenError};

mod id_table;
pub mod std_env;

use id_table::IdentificationTable;
use std_env::STANDARD_ENVIRONMENT;

pub struct Checker {
    id_table: IdentificationTable,
}

impl Checker {
    pub fn new() -> Self {
        let mut checker = Checker {
            id_table: IdentificationTable::new(),
        };
        checker.establish_standard_environment();
        checker
    }

    /// set up the standard environment (the prelude)
    fn establish_standard_environment(&mut self) {
        self.id_table.enter(
            String::from("Integer"),
            STANDARD_ENVIRONMENT.lock().unwrap().int_decl.clone(),
        );

        self.id_table.enter(
            String::from("Char"),
            STANDARD_ENVIRONMENT.lock().unwrap().char_decl.clone(),
        );

        self.id_table.enter(
            String::from("Boolean"),
            STANDARD_ENVIRONMENT.lock().unwrap().bool_decl.clone(),
        );
        self.id_table.enter(
            String::from("false"),
            STANDARD_ENVIRONMENT.lock().unwrap().false_decl.clone(),
        );
        self.id_table.enter(
            String::from("true"),
            STANDARD_ENVIRONMENT.lock().unwrap().true_decl.clone(),
        );

        self.id_table.enter(
            String::from("id"),
            STANDARD_ENVIRONMENT.lock().unwrap().id_decl.clone(),
        );
        self.id_table.enter(
            String::from("\\"),
            STANDARD_ENVIRONMENT.lock().unwrap().not_decl.clone(),
        );
        self.id_table.enter(
            String::from("/\\"),
            STANDARD_ENVIRONMENT.lock().unwrap().and_decl.clone(),
        );
        self.id_table.enter(
            String::from("\\/"),
            STANDARD_ENVIRONMENT.lock().unwrap().or_decl.clone(),
        );
        self.id_table.enter(
            String::from("succ"),
            STANDARD_ENVIRONMENT.lock().unwrap().succ_decl.clone(),
        );
        self.id_table.enter(
            String::from("pred"),
            STANDARD_ENVIRONMENT.lock().unwrap().pred_decl.clone(),
        );
        self.id_table.enter(
            String::from("neg"),
            STANDARD_ENVIRONMENT.lock().unwrap().neg_decl.clone(),
        );
        self.id_table.enter(
            String::from("+"),
            STANDARD_ENVIRONMENT.lock().unwrap().add_decl.clone(),
        );
        self.id_table.enter(
            String::from("-"),
            STANDARD_ENVIRONMENT.lock().unwrap().sub_decl.clone(),
        );
        self.id_table.enter(
            String::from("*"),
            STANDARD_ENVIRONMENT.lock().unwrap().mult_decl.clone(),
        );
        self.id_table.enter(
            String::from("/"),
            STANDARD_ENVIRONMENT.lock().unwrap().div_decl.clone(),
        );
        self.id_table.enter(
            String::from("//"),
            STANDARD_ENVIRONMENT.lock().unwrap().mod_decl.clone(),
        );
        self.id_table.enter(
            String::from("<"),
            STANDARD_ENVIRONMENT.lock().unwrap().lt_decl.clone(),
        );
        self.id_table.enter(
            String::from("<="),
            STANDARD_ENVIRONMENT.lock().unwrap().le_decl.clone(),
        );
        self.id_table.enter(
            String::from(">="),
            STANDARD_ENVIRONMENT.lock().unwrap().ge_decl.clone(),
        );
        self.id_table.enter(
            String::from(">"),
            STANDARD_ENVIRONMENT.lock().unwrap().gt_decl.clone(),
        );
        self.id_table.enter(
            String::from("="),
            STANDARD_ENVIRONMENT.lock().unwrap().eq_decl.clone(),
        );
        self.id_table.enter(
            String::from("/="),
            STANDARD_ENVIRONMENT.lock().unwrap().ne_decl.clone(),
        );
        self.id_table.enter(
            String::from("eol"),
            STANDARD_ENVIRONMENT.lock().unwrap().eol_decl.clone(),
        );
        self.id_table.enter(
            String::from("eof"),
            STANDARD_ENVIRONMENT.lock().unwrap().eof_decl.clone(),
        );
        self.id_table.enter(
            String::from("get"),
            STANDARD_ENVIRONMENT.lock().unwrap().get_decl.clone(),
        );
        self.id_table.enter(
            String::from("put"),
            STANDARD_ENVIRONMENT.lock().unwrap().put_decl.clone(),
        );
        self.id_table.enter(
            String::from("geteol"),
            STANDARD_ENVIRONMENT.lock().unwrap().geteol_decl.clone(),
        );
        self.id_table.enter(
            String::from("puteol"),
            STANDARD_ENVIRONMENT.lock().unwrap().puteol_decl.clone(),
        );
        self.id_table.enter(
            String::from("getint"),
            STANDARD_ENVIRONMENT.lock().unwrap().getint_decl.clone(),
        );
        self.id_table.enter(
            String::from("putint"),
            STANDARD_ENVIRONMENT.lock().unwrap().putint_decl.clone(),
        );
        self.id_table.enter(
            String::from("chr"),
            STANDARD_ENVIRONMENT.lock().unwrap().chr_decl.clone(),
        );
        self.id_table.enter(
            String::from("ord"),
            STANDARD_ENVIRONMENT.lock().unwrap().ord_decl.clone(),
        );
        self.id_table.enter(
            String::from("new"),
            STANDARD_ENVIRONMENT.lock().unwrap().new_decl.clone(),
        );
        self.id_table.enter(
            String::from("dispose"),
            STANDARD_ENVIRONMENT.lock().unwrap().dispose_decl.clone(),
        );
    }

    /// Check that the AST is well-formed, link all applied occurrences of identifiers and
    /// operators to their declarations, check that all expressions and typedenoters have
    /// proper types.
    pub fn check(&mut self, program: &mut Program) {
        program.accept(self, AstObject::Null);
    }
}

impl AstVisitor for Checker {
    fn visit_program(&mut self, program: &mut Program, arg: AstObject) -> AstObject {
        program.cmd.accept(self, arg.clone());
        AstObject::Null
    }

    fn visit_empty_command(&mut self, cmd: &mut EmptyCommandState, arg: AstObject) -> AstObject {
        AstObject::Null
    }

    fn visit_assign_command(&mut self, cmd: &mut AssignCommandState, arg: AstObject) -> AstObject {
        AstObject::Null
    }

    /// check that the identifier represents a procedure declaration, and then pass the formal
    /// parameter sequence downstream so that the actual parameter sequence can be validated against
    /// it.
    fn visit_call_command(&mut self, cmd: &mut CallCommandState, arg: AstObject) -> AstObject {
        let id_decl_ast = cmd.id.accept(self, arg.clone());

        if let Some(id_decl) = id_decl_ast.get_declaration() {
            if let Some(proc_decl) = id_decl.get_proc_declaration() {
                let fps = proc_decl.fps.clone();
                cmd.aps
                    .accept(self, AstObject::FormalParameterSequence(fps));
            } else {
                report_error_and_exit(GenError::from(CheckerError::new(
                    "expected a procedure here",
                )));
            }
        } else {
            report_error_and_exit(GenError::from(CheckerError::new(
                "expected a declaration here",
            )));
        }

        AstObject::Null
    }

    /// open a new scope, expand the declarations, and check the command in the context of the
    /// declarations, and finally close the scope.
    fn visit_let_command(&mut self, cmd: &mut LetCommandState, arg: AstObject) -> AstObject {
        self.id_table.open_scope();
        cmd.decl.accept(self, AstObject::Null);
        cmd.cmd.accept(self, AstObject::Null);
        self.id_table.close_scope();
        AstObject::Null
    }

    fn visit_if_command(&mut self, cmd: &mut IfCommandState, arg: AstObject) -> AstObject {
        AstObject::Null
    }

    fn visit_while_command(&mut self, cmd: &mut WhileCommandState, arg: AstObject) -> AstObject {
        AstObject::Null
    }

    fn visit_sequential_command(
        &mut self,
        cmd: &mut SequentialCommandState,
        arg: AstObject,
    ) -> AstObject {
        AstObject::Null
    }

    fn visit_empty_expression(
        &mut self,
        expr: &mut EmptyExpressionState,
        arg: AstObject,
    ) -> AstObject {
        AstObject::Null
    }

    /// annotate the integer expression with its type
    fn visit_integer_expression(
        &mut self,
        expr: &mut IntegerExpressionState,
        arg: AstObject,
    ) -> AstObject {
        if let Some(td) = expr.il.accept(self, arg).get_type_denoter() {
            expr.td = Some(td.clone());
        } else {
            report_error_and_exit(GenError::from(CheckerError::new(
                "could not resolve the type of an integer expression",
            )));
        }
        AstObject::TypeDenoter(expr.td.clone().unwrap())
    }

    fn visit_character_expression(
        &mut self,
        expr: &mut CharacterExpressionState,
        arg: AstObject,
    ) -> AstObject {
        AstObject::Null
    }

    fn visit_vname_expression(
        &mut self,
        expr: &mut VnameExpressionState,
        arg: AstObject,
    ) -> AstObject {
        AstObject::Null
    }

    fn visit_let_expression(&mut self, expr: &mut LetExpressionState, arg: AstObject) -> AstObject {
        AstObject::Null
    }

    fn visit_call_expression(
        &mut self,
        expr: &mut CallExpressionState,
        arg: AstObject,
    ) -> AstObject {
        AstObject::Null
    }

    fn visit_if_expression(&mut self, expr: &mut IfExpressionState, arg: AstObject) -> AstObject {
        AstObject::Null
    }

    fn visit_unary_expression(
        &mut self,
        expr: &mut UnaryExpressionState,
        arg: AstObject,
    ) -> AstObject {
        AstObject::Null
    }

    fn visit_binary_expression(
        &mut self,
        expr: &mut BinaryExpressionState,
        arg: AstObject,
    ) -> AstObject {
        AstObject::Null
    }

    fn visit_array_expression(
        &mut self,
        expr: &mut ArrayExpressionState,
        arg: AstObject,
    ) -> AstObject {
        AstObject::Null
    }

    fn visit_record_expression(
        &mut self,
        expr: &mut RecordExpressionState,
        arg: AstObject,
    ) -> AstObject {
        AstObject::Null
    }

    fn visit_single_array_aggregate(
        &mut self,
        agg: &mut SingleArrayAggregateState,
        arg: AstObject,
    ) -> AstObject {
        AstObject::Null
    }

    fn visit_multiple_array_aggregate(
        &mut self,
        agg: &mut MultipleArrayAggregateState,
        arg: AstObject,
    ) -> AstObject {
        AstObject::Null
    }

    fn visit_single_record_aggregate(
        &mut self,
        agg: &mut SingleRecordAggregateState,
        arg: AstObject,
    ) -> AstObject {
        AstObject::Null
    }

    fn visit_multiple_record_aggregate(
        &mut self,
        agg: &mut MultipleRecordAggregateState,
        arg: AstObject,
    ) -> AstObject {
        AstObject::Null
    }

    fn visit_const_declaration(
        &mut self,
        decl: &mut ConstDeclarationState,
        arg: AstObject,
    ) -> AstObject {
        AstObject::Null
    }

    fn visit_var_declaration(
        &mut self,
        decl: &mut VarDeclarationState,
        arg: AstObject,
    ) -> AstObject {
        AstObject::Null
    }

    fn visit_proc_declaration(
        &mut self,
        decl: &mut ProcDeclarationState,
        arg: AstObject,
    ) -> AstObject {
        AstObject::Null
    }

    fn visit_func_declaration(
        &mut self,
        decl: &mut FuncDeclarationState,
        arg: AstObject,
    ) -> AstObject {
        AstObject::Null
    }

    fn visit_type_declaration(
        &mut self,
        decl: &mut TypeDeclarationState,
        arg: AstObject,
    ) -> AstObject {
        AstObject::Null
    }

    fn visit_unary_operator_declaration(
        &mut self,
        decl: &mut UnaryOperatorDeclarationState,
        arg: AstObject,
    ) -> AstObject {
        AstObject::Null
    }

    fn visit_binary_operator_declaration(
        &mut self,
        decl: &mut BinaryOperatorDeclarationState,
        arg: AstObject,
    ) -> AstObject {
        AstObject::Null
    }

    fn visit_sequential_declaration(
        &mut self,
        decl: &mut SequentialDeclarationState,
        arg: AstObject,
    ) -> AstObject {
        AstObject::Null
    }

    fn visit_any_type_denoter(
        &mut self,
        td: &mut AnyTypeDenoterState,
        arg: AstObject,
    ) -> AstObject {
        AstObject::Null
    }

    fn visit_error_type_denoter(
        &mut self,
        td: &mut ErrorTypeDenoterState,
        arg: AstObject,
    ) -> AstObject {
        AstObject::Null
    }

    fn visit_bool_type_denoter(
        &mut self,
        td: &mut BoolTypeDenoterState,
        arg: AstObject,
    ) -> AstObject {
        AstObject::Null
    }

    fn visit_char_type_denoter(
        &mut self,
        td: &mut CharTypeDenoterState,
        arg: AstObject,
    ) -> AstObject {
        AstObject::Null
    }

    fn visit_int_type_denoter(
        &mut self,
        td: &mut IntTypeDenoterState,
        arg: AstObject,
    ) -> AstObject {
        AstObject::Null
    }

    fn visit_array_type_denoter(
        &mut self,
        td: &mut ArrayTypeDenoterState,
        arg: AstObject,
    ) -> AstObject {
        AstObject::Null
    }

    fn visit_simple_type_denoter(
        &mut self,
        td: &mut SimpleTypeDenoterState,
        arg: AstObject,
    ) -> AstObject {
        AstObject::Null
    }

    fn visit_single_field_type_denoter(
        &mut self,
        td: &mut SingleFieldTypeDenoterState,
        arg: AstObject,
    ) -> AstObject {
        AstObject::Null
    }

    fn visit_multiple_field_type_denoter(
        &mut self,
        td: &mut MultipleFieldTypeDenoterState,
        arg: AstObject,
    ) -> AstObject {
        AstObject::Null
    }

    fn visit_record_type_denoter(
        &mut self,
        td: &mut RecordTypeDenoterState,
        arg: AstObject,
    ) -> AstObject {
        AstObject::Null
    }

    fn visit_empty_formal_parameter_sequence(
        &mut self,
        fps: &mut EmptyFormalParameterSequenceState,
        arg: AstObject,
    ) -> AstObject {
        AstObject::Null
    }

    fn visit_single_formal_parameter_sequence(
        &mut self,
        fps: &mut SingleFormalParameterSequenceState,
        arg: AstObject,
    ) -> AstObject {
        AstObject::Null
    }

    fn visit_multiple_formal_parameter_sequence(
        &mut self,
        fps: &mut MultipleFormalParameterSequenceState,
        arg: AstObject,
    ) -> AstObject {
        AstObject::Null
    }

    fn visit_const_formal_parameter(
        &mut self,
        fp: &mut ConstFormalParameterState,
        arg: AstObject,
    ) -> AstObject {
        AstObject::Null
    }

    fn visit_var_formal_parameter(
        &mut self,
        fp: &mut VarFormalParameterState,
        arg: AstObject,
    ) -> AstObject {
        AstObject::Null
    }

    fn visit_proc_formal_parameter(
        &mut self,
        fp: &mut ProcFormalParameterState,
        arg: AstObject,
    ) -> AstObject {
        AstObject::Null
    }

    fn visit_func_formal_parameter(
        &mut self,
        fp: &mut FuncFormalParameterState,
        arg: AstObject,
    ) -> AstObject {
        AstObject::Null
    }

    fn visit_empty_actual_parameter_sequence(
        &mut self,
        aps: &mut EmptyActualParameterSequenceState,
        arg: AstObject,
    ) -> AstObject {
        AstObject::Null
    }

    /// check that the formal parameter sequence passed in via arg is a single formal parameter
    /// sequence, extract the formal parameter, and pass that downstream to validate the actual
    /// parameter against.
    fn visit_single_actual_parameter_sequence(
        &mut self,
        aps: &mut SingleActualParameterSequenceState,
        arg: AstObject,
    ) -> AstObject {
        if let Some(fps) = arg.get_formal_parameter_sequence() {
            if let Some(sfps) = fps.get_single_formal_parameter_sequence() {
                aps.ap
                    .accept(self, AstObject::FormalParameter(sfps.fp.clone()));
            } else {
                report_error_and_exit(GenError::from(CheckerError::new(
                    "expected a single formal parameter sequence here",
                )));
            }
        } else {
            report_error_and_exit(GenError::from(CheckerError::new(
                "expected a formal parameter sequence here",
            )));
        }

        AstObject::Null
    }

    /// check that the formal parameter sequence passed in via arg is a multiple formal parameter
    /// sequence, extract the formal parameter, pass that downstream to validate against the actual
    /// parameter, and then check the remaining formal parameter sequence as well.
    fn visit_multiple_actual_parameter_sequence(
        &mut self,
        aps: &mut MultipleActualParameterSequenceState,
        arg: AstObject,
    ) -> AstObject {
        if let Some(fps) = arg.get_formal_parameter_sequence() {
            if let Some(mfps) = fps.get_multiple_formal_parameter_sequence() {
                aps.ap
                    .accept(self, AstObject::FormalParameter(mfps.fp.clone()));
                aps.aps
                    .accept(self, AstObject::FormalParameterSequence(mfps.fps.clone()));
            } else {
                report_error_and_exit(GenError::from(CheckerError::new(
                    "expected a multiple formal parameter sequence here",
                )));
            }
        } else {
            report_error_and_exit(GenError::from(CheckerError::new(
                "expected a formal parameter sequence here",
            )));
        }
        AstObject::Null
    }

    /// check that the formal parameter passed in via arg is a const formal parameter,
    /// and check that its type matches that of the const actual parameter.
    fn visit_const_actual_parameter(
        &mut self,
        ap: &mut ConstActualParameterState,
        arg: AstObject,
    ) -> AstObject {
        if let Some(fp) = arg.get_formal_parameter() {
            if let Some(cfp) = fp.get_const_formal_parameter() {
                let expected_td = cfp.td.clone();
                let actual_td = ap
                    .expr
                    .accept(self, AstObject::Null)
                    .get_type_denoter()
                    .unwrap()
                    .clone();

                if *expected_td != *actual_td {
                    report_error_and_exit(GenError::from(CheckerError::new(&format!(
                        "expected type was {}, actual type was {}",
                        expected_td, actual_td
                    ))));
                }
            } else {
                report_error_and_exit(GenError::from(CheckerError::new(
                    "expected a const formal parameter here",
                )));
            }
        } else {
            report_error_and_exit(GenError::from(CheckerError::new(
                "expected a formal parameter here",
            )));
        }
        AstObject::Null
    }

    fn visit_var_actual_parameter(
        &mut self,
        ap: &mut VarActualParameterState,
        arg: AstObject,
    ) -> AstObject {
        AstObject::Null
    }

    fn visit_proc_actual_parameter(
        &mut self,
        ap: &mut ProcActualParameterState,
        arg: AstObject,
    ) -> AstObject {
        AstObject::Null
    }

    fn visit_func_actual_parameter(
        &mut self,
        ap: &mut FuncActualParameterState,
        arg: AstObject,
    ) -> AstObject {
        AstObject::Null
    }

    fn visit_simple_vname(&mut self, vname: &mut SimpleVnameState, arg: AstObject) -> AstObject {
        AstObject::Null
    }

    fn visit_dot_vname(&mut self, vname: &mut DotVnameState, arg: AstObject) -> AstObject {
        AstObject::Null
    }

    fn visit_subscript_vname(
        &mut self,
        vname: &mut SubscriptVnameState,
        arg: AstObject,
    ) -> AstObject {
        AstObject::Null
    }

    fn visit_identifier(&mut self, id: &mut Identifier, arg: AstObject) -> AstObject {
        if let Some(decl) = self.id_table.retrieve(&id.spelling) {
            id.decl = Some(Box::new(*decl.clone()));
            return AstObject::Declaration(id.decl.clone().unwrap());
        }
        AstObject::Null
    }

    /// this is the standard int type
    fn visit_integer_literal(&mut self, il: &mut IntegerLiteral, arg: AstObject) -> AstObject {
        AstObject::TypeDenoter(Box::new(
            STANDARD_ENVIRONMENT.lock().unwrap().int_type.clone(),
        ))
    }

    fn visit_character_literal(&mut self, cl: &mut CharacterLiteral, arg: AstObject) -> AstObject {
        AstObject::TypeDenoter(Box::new(
            STANDARD_ENVIRONMENT.lock().unwrap().char_type.clone(),
        ))
    }

    fn visit_operator(&mut self, op: &mut Operator, arg: AstObject) -> AstObject {
        AstObject::Null
    }
}
